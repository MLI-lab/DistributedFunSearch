"""
Finds large independent set in graph G where nodes are binary strings of length n.
Nodes in G are connected if they share a subsequence of length at least length n-s. 

On every iteration, improve the priority_v5 function over its previous versions above.
Try to make the code short.
"""

import itertools
import numpy as np
import networkx as nx

def generate_graph(n, s):
  G = nx.Graph()
  sequences = [''.join(seq) for seq in itertools.product('01', repeat=n)]  # forms nth cartesian product of 0,1 to enumerate all sequences

  # Adding nodes
  for seq in sequences:
    G.add_node(seq)

  # Adding edges
  for i in range(len(sequences)):
    for j in range(i + 1, len(sequences)):  # no self comparison and repeated comparisons
      if has_common_subsequence(sequences[i], sequences[j], n, s):
        G.add_edge(sequences[i], sequences[j])
  return G

def has_common_subsequence(seq1, seq2, n, s):
  threshold = n - s
  if threshold <= 0:
    return True  # Trivial case where subsequence is length 0 or negative
  # Initialize two rows for DP
  prev = [0] * (n + 1)  # all zeros vector of dim n+1 (also consider empty sequence case)
  current = [0] * (n + 1)  # all zeros vector of dim n+1 (also consider empty sequence case)

  # Fill the DP table row by row
  for i in range(1, n + 1):  # iterate over symbols in seq1
    for j in range(1, n + 1):  # iterate over symbols in seq2
      if seq1[i - 1] == seq2[j - 1]:  # python 0 indexing
        current[j] = prev[j - 1] + 1
      else:
        current[j] = max(prev[j], current[j - 1])

      # Check if the current length of LCS meets the threshold
      if current[j] >= threshold:
        return True

    # Swap current and prev rows for next iteration
    prev, current = current, prev

  return False  # No LCS of adequate length was found

def evaluate(params):
  n,s= params
  independent_set = solve(n, s)
  return len(independent_set)

def solve(n, s):
  # Generate graph
  G = generate_graph(n, s)
  # Dictionary to hold the priority of each node
  priorities = {node: priority(node, G, n, s) for node in G.nodes}

  # Set to keep track of the independent set
  independent_set = set()

  # Process nodes in descending order of their priorities
  for node in sorted(G.nodes, key=lambda x: priorities[x], reverse=True):
    if priorities[node] == -np.inf:
      continue  # This node has been invalidated
    # Add the node to the independent set
    independent_set.add(node)
    # Invalidate this node and all its neighbors
    priorities[node] = -np.inf
    for neighbor in G.neighbors(node):
      priorities[neighbor] = -np.inf

  return independent_set

def priority(node, G, n, s):
    """
    Returns the priority with which we want to add `node` to independent set.
    """
    return 0.0 