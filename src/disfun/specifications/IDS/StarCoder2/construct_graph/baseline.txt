"""
Finds large independent set in graph G where nodes are q-ary strings of length n.
Nodes in G are connected if their edit distance < 2s + 1.

For a code to correct s errors (insertions, deletions, or substitutions),
all codewords must have pairwise edit distance >= 2s + 1.

Improve the `priority_v2` function over its previous versions below.
Keep the code short and comment for easy understanding.
"""

import itertools
import hashlib
import numpy as np
import networkx as nx
import json
import Levenshtein


def generate_graph(n, s, q):
    """
    Generate a graph where nodes are q-ary strings of length n.
    Two nodes are connected if edit_distance(node1, node2) < 2s + 1.
    """
    G = nx.Graph()
    alphabet = ''.join(str(i) for i in range(q))
    sequences = [''.join(seq) for seq in itertools.product(alphabet, repeat=n)]

    # Add all nodes
    for seq in sequences:
        G.add_node(seq)

    # Add edges between nodes with insufficient edit distance
    threshold = 2 * s + 1
    for i in range(len(sequences)):
        for j in range(i + 1, len(sequences)):
            if Levenshtein.distance(sequences[i], sequences[j]) < threshold:
                G.add_edge(sequences[i], sequences[j])

    return G


def hash_priority_mapping(priorities, sequences):
    """
    Generate a hash based on the mapping of sequences to their priority scores.
    """
    mapping = [(seq, priorities[seq]) for seq in sequences]
    mapping_sorted = sorted(mapping, key=lambda x: x[0])  # Sort by sequence
    mapping_str = ','.join(f'{seq}:{score}' for seq, score in mapping_sorted)
    return hashlib.sha256(mapping_str.encode()).hexdigest()


def evaluate(params):
    n, s, q = params
    independent_set, hash_value = solve(n, s, q)
    return (len(independent_set), hash_value)


def solve(n, s, q):
    G_original = generate_graph(n, s, q)
    G_for_priority = G_original.copy()  # Pass copy to priority function
    alphabet = ''.join(str(i) for i in range(q))
    sequences = [''.join(seq) for seq in itertools.product(alphabet, repeat=n)]
    priorities = {node: priority(node, G_for_priority, n, s) for node in G_original.nodes}
    nodes_sorted = sorted(G_original.nodes, key=lambda x: (-priorities[x], x))
    independent_set = set()
    for node in nodes_sorted:
        if node not in G_original:
            continue
        independent_set.add(node)
        neighbors = list(G_original.neighbors(node))
        G_original.remove_node(node)
        G_original.remove_nodes_from(neighbors)
    hash_value = None
    if n == start_n:
        hash_value = hash_priority_mapping(priorities, sequences)
    return independent_set, hash_value


def priority(node, G, n, s):
    """Returns the priority with which we want to add `node` to independent set."""
    return 0.0
